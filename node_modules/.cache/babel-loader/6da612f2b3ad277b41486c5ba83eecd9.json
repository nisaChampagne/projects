{"ast":null,"code":"'use strict';\n\nvar Mixin = require('../../utils/mixin'),\n    Tokenizer = require('../../tokenizer'),\n    LocationInfoTokenizerMixin = require('./tokenizer_mixin'),\n    PositionTrackingPreprocessorMixin = require('../position_tracking/preprocessor_mixin'),\n    LocationInfoOpenElementStackMixin = require('./open_element_stack_mixin'),\n    HTML = require('../../common/html'),\n    inherits = require('util').inherits; //Aliases\n\n\nvar $ = HTML.TAG_NAMES;\n\nvar LocationInfoParserMixin = module.exports = function (parser) {\n  Mixin.call(this, parser);\n  this.parser = parser;\n  this.posTracker = null;\n  this.lastStartTagToken = null;\n  this.lastFosterParentingLocation = null;\n  this.currentToken = null;\n};\n\ninherits(LocationInfoParserMixin, Mixin);\n\nLocationInfoParserMixin.prototype._setStartLocation = function (element) {\n  if (this.lastStartTagToken) {\n    element.__location = Object.create(this.lastStartTagToken.location);\n    element.__location.startTag = this.lastStartTagToken.location;\n  } else element.__location = null;\n};\n\nLocationInfoParserMixin.prototype._setEndLocation = function (element, closingToken) {\n  var loc = element.__location;\n\n  if (loc) {\n    if (closingToken.location) {\n      var ctLoc = closingToken.location,\n          tn = this.parser.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n      // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n\n      var isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n\n      if (isClosingEndTag) {\n        loc.endTag = Object.create(ctLoc);\n        loc.endOffset = ctLoc.endOffset;\n      } else loc.endOffset = ctLoc.startOffset;\n    } else if (closingToken.type === Tokenizer.EOF_TOKEN) loc.endOffset = this.posTracker.offset;\n  }\n};\n\nLocationInfoParserMixin.prototype._getOverriddenMethods = function (mxn, orig) {\n  return {\n    _bootstrap: function (document, fragmentContext) {\n      orig._bootstrap.call(this, document, fragmentContext);\n\n      mxn.lastStartTagToken = null;\n      mxn.lastFosterParentingLocation = null;\n      mxn.currentToken = null;\n      mxn.posTracker = new PositionTrackingPreprocessorMixin(this.tokenizer.preprocessor);\n      new LocationInfoTokenizerMixin(this.tokenizer);\n      new LocationInfoOpenElementStackMixin(this.openElements, {\n        onItemPop: function (element) {\n          mxn._setEndLocation(element, mxn.currentToken);\n        }\n      });\n    },\n    _runParsingLoop: function (scriptHandler) {\n      orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements\n      // that remains on open element stack\n\n\n      for (var i = this.openElements.stackTop; i >= 0; i--) mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n    },\n    //Token processing\n    _processTokenInForeignContent: function (token) {\n      mxn.currentToken = token;\n\n      orig._processTokenInForeignContent.call(this, token);\n    },\n    _processToken: function (token) {\n      mxn.currentToken = token;\n\n      orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n      //their end location explicitly.\n\n\n      var requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n\n      if (requireExplicitUpdate) {\n        for (var i = this.openElements.stackTop; i >= 0; i--) {\n          var element = this.openElements.items[i];\n\n          if (this.treeAdapter.getTagName(element) === token.tagName) {\n            mxn._setEndLocation(element, token);\n\n            break;\n          }\n        }\n      }\n    },\n    //Doctype\n    _setDocumentType: function (token) {\n      orig._setDocumentType.call(this, token);\n\n      var documentChildren = this.treeAdapter.getChildNodes(this.document),\n          cnLength = documentChildren.length;\n\n      for (var i = 0; i < cnLength; i++) {\n        var node = documentChildren[i];\n\n        if (this.treeAdapter.isDocumentTypeNode(node)) {\n          node.__location = token.location;\n          break;\n        }\n      }\n    },\n    //Elements\n    _attachElementToTree: function (element) {\n      //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n      //So we will use token location stored in this methods for the element.\n      mxn._setStartLocation(element);\n\n      mxn.lastStartTagToken = null;\n\n      orig._attachElementToTree.call(this, element);\n    },\n    _appendElement: function (token, namespaceURI) {\n      mxn.lastStartTagToken = token;\n\n      orig._appendElement.call(this, token, namespaceURI);\n    },\n    _insertElement: function (token, namespaceURI) {\n      mxn.lastStartTagToken = token;\n\n      orig._insertElement.call(this, token, namespaceURI);\n    },\n    _insertTemplate: function (token) {\n      mxn.lastStartTagToken = token;\n\n      orig._insertTemplate.call(this, token);\n\n      var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n      tmplContent.__location = null;\n    },\n    _insertFakeRootElement: function () {\n      orig._insertFakeRootElement.call(this);\n\n      this.openElements.current.__location = null;\n    },\n    //Comments\n    _appendCommentNode: function (token, parent) {\n      orig._appendCommentNode.call(this, token, parent);\n\n      var children = this.treeAdapter.getChildNodes(parent),\n          commentNode = children[children.length - 1];\n      commentNode.__location = token.location;\n    },\n    //Text\n    _findFosterParentingLocation: function () {\n      //NOTE: store last foster parenting location, so we will be able to find inserted text\n      //in case of foster parenting\n      mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n      return mxn.lastFosterParentingLocation;\n    },\n    _insertCharacters: function (token) {\n      orig._insertCharacters.call(this, token);\n\n      var hasFosterParent = this._shouldFosterParentOnInsertion(),\n          parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current,\n          siblings = this.treeAdapter.getChildNodes(parent),\n          textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1,\n          textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n\n      if (textNode.__location) textNode.__location.endOffset = token.location.endOffset;else textNode.__location = token.location;\n    }\n  };\n};","map":{"version":3,"sources":["/Users/lambda_school_loaner_244/Desktop/LAMBDA/projects/projectsCollection/node_modules/parse5/lib/extensions/location_info/parser_mixin.js"],"names":["Mixin","require","Tokenizer","LocationInfoTokenizerMixin","PositionTrackingPreprocessorMixin","LocationInfoOpenElementStackMixin","HTML","inherits","$","TAG_NAMES","LocationInfoParserMixin","module","exports","parser","call","posTracker","lastStartTagToken","lastFosterParentingLocation","currentToken","prototype","_setStartLocation","element","__location","Object","create","location","startTag","_setEndLocation","closingToken","loc","ctLoc","tn","treeAdapter","getTagName","isClosingEndTag","type","END_TAG_TOKEN","tagName","endTag","endOffset","startOffset","EOF_TOKEN","offset","_getOverriddenMethods","mxn","orig","_bootstrap","document","fragmentContext","tokenizer","preprocessor","openElements","onItemPop","_runParsingLoop","scriptHandler","i","stackTop","items","_processTokenInForeignContent","token","_processToken","requireExplicitUpdate","BODY","hasInScope","_setDocumentType","documentChildren","getChildNodes","cnLength","length","node","isDocumentTypeNode","_attachElementToTree","_appendElement","namespaceURI","_insertElement","_insertTemplate","tmplContent","getTemplateContent","current","_insertFakeRootElement","_appendCommentNode","parent","children","commentNode","_findFosterParentingLocation","_insertCharacters","hasFosterParent","_shouldFosterParentOnInsertion","currentTmplContent","siblings","textNodeIdx","beforeElement","indexOf","textNode"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,mBAAD,CAAnB;AAAA,IACIC,SAAS,GAAGD,OAAO,CAAC,iBAAD,CADvB;AAAA,IAEIE,0BAA0B,GAAGF,OAAO,CAAC,mBAAD,CAFxC;AAAA,IAGIG,iCAAiC,GAAGH,OAAO,CAAC,yCAAD,CAH/C;AAAA,IAIII,iCAAiC,GAAGJ,OAAO,CAAC,4BAAD,CAJ/C;AAAA,IAKIK,IAAI,GAAGL,OAAO,CAAC,mBAAD,CALlB;AAAA,IAMIM,QAAQ,GAAGN,OAAO,CAAC,MAAD,CAAP,CAAgBM,QAN/B,C,CASA;;;AACA,IAAIC,CAAC,GAAGF,IAAI,CAACG,SAAb;;AAEA,IAAIC,uBAAuB,GAAGC,MAAM,CAACC,OAAP,GAAiB,UAAUC,MAAV,EAAkB;AAC7Db,EAAAA,KAAK,CAACc,IAAN,CAAW,IAAX,EAAiBD,MAAjB;AAEA,OAAKA,MAAL,GAAcA,MAAd;AACA,OAAKE,UAAL,GAAkB,IAAlB;AACA,OAAKC,iBAAL,GAAyB,IAAzB;AACA,OAAKC,2BAAL,GAAmC,IAAnC;AACA,OAAKC,YAAL,GAAoB,IAApB;AACH,CARD;;AAUAX,QAAQ,CAACG,uBAAD,EAA0BV,KAA1B,CAAR;;AAGAU,uBAAuB,CAACS,SAAxB,CAAkCC,iBAAlC,GAAsD,UAAUC,OAAV,EAAmB;AACrE,MAAI,KAAKL,iBAAT,EAA4B;AACxBK,IAAAA,OAAO,CAACC,UAAR,GAAqBC,MAAM,CAACC,MAAP,CAAc,KAAKR,iBAAL,CAAuBS,QAArC,CAArB;AACAJ,IAAAA,OAAO,CAACC,UAAR,CAAmBI,QAAnB,GAA8B,KAAKV,iBAAL,CAAuBS,QAArD;AACH,GAHD,MAKIJ,OAAO,CAACC,UAAR,GAAqB,IAArB;AACP,CAPD;;AASAZ,uBAAuB,CAACS,SAAxB,CAAkCQ,eAAlC,GAAoD,UAAUN,OAAV,EAAmBO,YAAnB,EAAiC;AACjF,MAAIC,GAAG,GAAGR,OAAO,CAACC,UAAlB;;AAEA,MAAIO,GAAJ,EAAS;AACL,QAAID,YAAY,CAACH,QAAjB,EAA2B;AACvB,UAAIK,KAAK,GAAGF,YAAY,CAACH,QAAzB;AAAA,UACIM,EAAE,GAAG,KAAKlB,MAAL,CAAYmB,WAAZ,CAAwBC,UAAxB,CAAmCZ,OAAnC,CADT,CADuB,CAIvB;AACA;;AACA,UAAIa,eAAe,GAAGN,YAAY,CAACO,IAAb,KAAsBjC,SAAS,CAACkC,aAAhC,IAAiDL,EAAE,KAAKH,YAAY,CAACS,OAA3F;;AAEA,UAAIH,eAAJ,EAAqB;AACjBL,QAAAA,GAAG,CAACS,MAAJ,GAAaf,MAAM,CAACC,MAAP,CAAcM,KAAd,CAAb;AACAD,QAAAA,GAAG,CAACU,SAAJ,GAAgBT,KAAK,CAACS,SAAtB;AACH,OAHD,MAMIV,GAAG,CAACU,SAAJ,GAAgBT,KAAK,CAACU,WAAtB;AACP,KAfD,MAiBK,IAAIZ,YAAY,CAACO,IAAb,KAAsBjC,SAAS,CAACuC,SAApC,EACDZ,GAAG,CAACU,SAAJ,GAAgB,KAAKxB,UAAL,CAAgB2B,MAAhC;AACP;AACJ,CAxBD;;AA0BAhC,uBAAuB,CAACS,SAAxB,CAAkCwB,qBAAlC,GAA0D,UAAUC,GAAV,EAAeC,IAAf,EAAqB;AAC3E,SAAO;AACHC,IAAAA,UAAU,EAAE,UAAUC,QAAV,EAAoBC,eAApB,EAAqC;AAC7CH,MAAAA,IAAI,CAACC,UAAL,CAAgBhC,IAAhB,CAAqB,IAArB,EAA2BiC,QAA3B,EAAqCC,eAArC;;AAEAJ,MAAAA,GAAG,CAAC5B,iBAAJ,GAAwB,IAAxB;AACA4B,MAAAA,GAAG,CAAC3B,2BAAJ,GAAkC,IAAlC;AACA2B,MAAAA,GAAG,CAAC1B,YAAJ,GAAmB,IAAnB;AACA0B,MAAAA,GAAG,CAAC7B,UAAJ,GAAiB,IAAIX,iCAAJ,CAAsC,KAAK6C,SAAL,CAAeC,YAArD,CAAjB;AAEA,UAAI/C,0BAAJ,CAA+B,KAAK8C,SAApC;AAEA,UAAI5C,iCAAJ,CAAsC,KAAK8C,YAA3C,EAAyD;AACrDC,QAAAA,SAAS,EAAE,UAAU/B,OAAV,EAAmB;AAC1BuB,UAAAA,GAAG,CAACjB,eAAJ,CAAoBN,OAApB,EAA6BuB,GAAG,CAAC1B,YAAjC;AACH;AAHoD,OAAzD;AAKH,KAhBE;AAkBHmC,IAAAA,eAAe,EAAE,UAAUC,aAAV,EAAyB;AACtCT,MAAAA,IAAI,CAACQ,eAAL,CAAqBvC,IAArB,CAA0B,IAA1B,EAAgCwC,aAAhC,EADsC,CAGtC;AACA;;;AACA,WAAK,IAAIC,CAAC,GAAG,KAAKJ,YAAL,CAAkBK,QAA/B,EAAyCD,CAAC,IAAI,CAA9C,EAAiDA,CAAC,EAAlD,EACIX,GAAG,CAACjB,eAAJ,CAAoB,KAAKwB,YAAL,CAAkBM,KAAlB,CAAwBF,CAAxB,CAApB,EAAgDX,GAAG,CAAC1B,YAApD;AACP,KAzBE;AA4BH;AACAwC,IAAAA,6BAA6B,EAAE,UAAUC,KAAV,EAAiB;AAC5Cf,MAAAA,GAAG,CAAC1B,YAAJ,GAAmByC,KAAnB;;AACAd,MAAAA,IAAI,CAACa,6BAAL,CAAmC5C,IAAnC,CAAwC,IAAxC,EAA8C6C,KAA9C;AACH,KAhCE;AAkCHC,IAAAA,aAAa,EAAE,UAAUD,KAAV,EAAiB;AAC5Bf,MAAAA,GAAG,CAAC1B,YAAJ,GAAmByC,KAAnB;;AACAd,MAAAA,IAAI,CAACe,aAAL,CAAmB9C,IAAnB,CAAwB,IAAxB,EAA8B6C,KAA9B,EAF4B,CAI5B;AACA;;;AACA,UAAIE,qBAAqB,GAAGF,KAAK,CAACxB,IAAN,KAAejC,SAAS,CAACkC,aAAzB,KACCuB,KAAK,CAACtB,OAAN,KAAkB7B,CAAC,CAACF,IAApB,IACAqD,KAAK,CAACtB,OAAN,KAAkB7B,CAAC,CAACsD,IAApB,IAA4B,KAAKX,YAAL,CAAkBY,UAAlB,CAA6BvD,CAAC,CAACsD,IAA/B,CAF7B,CAA5B;;AAIA,UAAID,qBAAJ,EAA2B;AACvB,aAAK,IAAIN,CAAC,GAAG,KAAKJ,YAAL,CAAkBK,QAA/B,EAAyCD,CAAC,IAAI,CAA9C,EAAiDA,CAAC,EAAlD,EAAsD;AAClD,cAAIlC,OAAO,GAAG,KAAK8B,YAAL,CAAkBM,KAAlB,CAAwBF,CAAxB,CAAd;;AAEA,cAAI,KAAKvB,WAAL,CAAiBC,UAAjB,CAA4BZ,OAA5B,MAAyCsC,KAAK,CAACtB,OAAnD,EAA4D;AACxDO,YAAAA,GAAG,CAACjB,eAAJ,CAAoBN,OAApB,EAA6BsC,KAA7B;;AACA;AACH;AACJ;AACJ;AACJ,KAtDE;AAyDH;AACAK,IAAAA,gBAAgB,EAAE,UAAUL,KAAV,EAAiB;AAC/Bd,MAAAA,IAAI,CAACmB,gBAAL,CAAsBlD,IAAtB,CAA2B,IAA3B,EAAiC6C,KAAjC;;AAEA,UAAIM,gBAAgB,GAAG,KAAKjC,WAAL,CAAiBkC,aAAjB,CAA+B,KAAKnB,QAApC,CAAvB;AAAA,UACIoB,QAAQ,GAAGF,gBAAgB,CAACG,MADhC;;AAGA,WAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,QAApB,EAA8BZ,CAAC,EAA/B,EAAmC;AAC/B,YAAIc,IAAI,GAAGJ,gBAAgB,CAACV,CAAD,CAA3B;;AAEA,YAAI,KAAKvB,WAAL,CAAiBsC,kBAAjB,CAAoCD,IAApC,CAAJ,EAA+C;AAC3CA,UAAAA,IAAI,CAAC/C,UAAL,GAAkBqC,KAAK,CAAClC,QAAxB;AACA;AACH;AACJ;AACJ,KAxEE;AA2EH;AACA8C,IAAAA,oBAAoB,EAAE,UAAUlD,OAAV,EAAmB;AACrC;AACA;AACAuB,MAAAA,GAAG,CAACxB,iBAAJ,CAAsBC,OAAtB;;AACAuB,MAAAA,GAAG,CAAC5B,iBAAJ,GAAwB,IAAxB;;AACA6B,MAAAA,IAAI,CAAC0B,oBAAL,CAA0BzD,IAA1B,CAA+B,IAA/B,EAAqCO,OAArC;AACH,KAlFE;AAoFHmD,IAAAA,cAAc,EAAE,UAAUb,KAAV,EAAiBc,YAAjB,EAA+B;AAC3C7B,MAAAA,GAAG,CAAC5B,iBAAJ,GAAwB2C,KAAxB;;AACAd,MAAAA,IAAI,CAAC2B,cAAL,CAAoB1D,IAApB,CAAyB,IAAzB,EAA+B6C,KAA/B,EAAsCc,YAAtC;AACH,KAvFE;AAyFHC,IAAAA,cAAc,EAAE,UAAUf,KAAV,EAAiBc,YAAjB,EAA+B;AAC3C7B,MAAAA,GAAG,CAAC5B,iBAAJ,GAAwB2C,KAAxB;;AACAd,MAAAA,IAAI,CAAC6B,cAAL,CAAoB5D,IAApB,CAAyB,IAAzB,EAA+B6C,KAA/B,EAAsCc,YAAtC;AACH,KA5FE;AA8FHE,IAAAA,eAAe,EAAE,UAAUhB,KAAV,EAAiB;AAC9Bf,MAAAA,GAAG,CAAC5B,iBAAJ,GAAwB2C,KAAxB;;AACAd,MAAAA,IAAI,CAAC8B,eAAL,CAAqB7D,IAArB,CAA0B,IAA1B,EAAgC6C,KAAhC;;AAEA,UAAIiB,WAAW,GAAG,KAAK5C,WAAL,CAAiB6C,kBAAjB,CAAoC,KAAK1B,YAAL,CAAkB2B,OAAtD,CAAlB;AAEAF,MAAAA,WAAW,CAACtD,UAAZ,GAAyB,IAAzB;AACH,KArGE;AAuGHyD,IAAAA,sBAAsB,EAAE,YAAY;AAChClC,MAAAA,IAAI,CAACkC,sBAAL,CAA4BjE,IAA5B,CAAiC,IAAjC;;AACA,WAAKqC,YAAL,CAAkB2B,OAAlB,CAA0BxD,UAA1B,GAAuC,IAAvC;AACH,KA1GE;AA4GH;AACA0D,IAAAA,kBAAkB,EAAE,UAAUrB,KAAV,EAAiBsB,MAAjB,EAAyB;AACzCpC,MAAAA,IAAI,CAACmC,kBAAL,CAAwBlE,IAAxB,CAA6B,IAA7B,EAAmC6C,KAAnC,EAA0CsB,MAA1C;;AAEA,UAAIC,QAAQ,GAAG,KAAKlD,WAAL,CAAiBkC,aAAjB,CAA+Be,MAA/B,CAAf;AAAA,UACIE,WAAW,GAAGD,QAAQ,CAACA,QAAQ,CAACd,MAAT,GAAkB,CAAnB,CAD1B;AAGAe,MAAAA,WAAW,CAAC7D,UAAZ,GAAyBqC,KAAK,CAAClC,QAA/B;AACH,KApHE;AAsHH;AACA2D,IAAAA,4BAA4B,EAAE,YAAY;AACtC;AACA;AACAxC,MAAAA,GAAG,CAAC3B,2BAAJ,GAAkC4B,IAAI,CAACuC,4BAAL,CAAkCtE,IAAlC,CAAuC,IAAvC,CAAlC;AAEA,aAAO8B,GAAG,CAAC3B,2BAAX;AACH,KA7HE;AA+HHoE,IAAAA,iBAAiB,EAAE,UAAU1B,KAAV,EAAiB;AAChCd,MAAAA,IAAI,CAACwC,iBAAL,CAAuBvE,IAAvB,CAA4B,IAA5B,EAAkC6C,KAAlC;;AAEA,UAAI2B,eAAe,GAAG,KAAKC,8BAAL,EAAtB;AAAA,UACIN,MAAM,GAAGK,eAAe,IAAI1C,GAAG,CAAC3B,2BAAJ,CAAgCgE,MAAnD,IACA,KAAK9B,YAAL,CAAkBqC,kBADlB,IAEA,KAAKrC,YAAL,CAAkB2B,OAH/B;AAAA,UAIIW,QAAQ,GAAG,KAAKzD,WAAL,CAAiBkC,aAAjB,CAA+Be,MAA/B,CAJf;AAAA,UAKIS,WAAW,GAAGJ,eAAe,IAAI1C,GAAG,CAAC3B,2BAAJ,CAAgC0E,aAAnD,GACdF,QAAQ,CAACG,OAAT,CAAiBhD,GAAG,CAAC3B,2BAAJ,CAAgC0E,aAAjD,IAAkE,CADpD,GAEdF,QAAQ,CAACrB,MAAT,GAAkB,CAPtB;AAAA,UAQIyB,QAAQ,GAAGJ,QAAQ,CAACC,WAAD,CARvB,CAHgC,CAahC;;;AACA,UAAIG,QAAQ,CAACvE,UAAb,EACIuE,QAAQ,CAACvE,UAAT,CAAoBiB,SAApB,GAAgCoB,KAAK,CAAClC,QAAN,CAAec,SAA/C,CADJ,KAIIsD,QAAQ,CAACvE,UAAT,GAAsBqC,KAAK,CAAClC,QAA5B;AACP;AAlJE,GAAP;AAoJH,CArJD","sourcesContent":["'use strict';\n\nvar Mixin = require('../../utils/mixin'),\n    Tokenizer = require('../../tokenizer'),\n    LocationInfoTokenizerMixin = require('./tokenizer_mixin'),\n    PositionTrackingPreprocessorMixin = require('../position_tracking/preprocessor_mixin'),\n    LocationInfoOpenElementStackMixin = require('./open_element_stack_mixin'),\n    HTML = require('../../common/html'),\n    inherits = require('util').inherits;\n\n\n//Aliases\nvar $ = HTML.TAG_NAMES;\n\nvar LocationInfoParserMixin = module.exports = function (parser) {\n    Mixin.call(this, parser);\n\n    this.parser = parser;\n    this.posTracker = null;\n    this.lastStartTagToken = null;\n    this.lastFosterParentingLocation = null;\n    this.currentToken = null;\n};\n\ninherits(LocationInfoParserMixin, Mixin);\n\n\nLocationInfoParserMixin.prototype._setStartLocation = function (element) {\n    if (this.lastStartTagToken) {\n        element.__location = Object.create(this.lastStartTagToken.location);\n        element.__location.startTag = this.lastStartTagToken.location;\n    }\n    else\n        element.__location = null;\n};\n\nLocationInfoParserMixin.prototype._setEndLocation = function (element, closingToken) {\n    var loc = element.__location;\n\n    if (loc) {\n        if (closingToken.location) {\n            var ctLoc = closingToken.location,\n                tn = this.parser.treeAdapter.getTagName(element);\n\n            // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n            // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n            var isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n\n            if (isClosingEndTag) {\n                loc.endTag = Object.create(ctLoc);\n                loc.endOffset = ctLoc.endOffset;\n            }\n\n            else\n                loc.endOffset = ctLoc.startOffset;\n        }\n\n        else if (closingToken.type === Tokenizer.EOF_TOKEN)\n            loc.endOffset = this.posTracker.offset;\n    }\n};\n\nLocationInfoParserMixin.prototype._getOverriddenMethods = function (mxn, orig) {\n    return {\n        _bootstrap: function (document, fragmentContext) {\n            orig._bootstrap.call(this, document, fragmentContext);\n\n            mxn.lastStartTagToken = null;\n            mxn.lastFosterParentingLocation = null;\n            mxn.currentToken = null;\n            mxn.posTracker = new PositionTrackingPreprocessorMixin(this.tokenizer.preprocessor);\n\n            new LocationInfoTokenizerMixin(this.tokenizer);\n\n            new LocationInfoOpenElementStackMixin(this.openElements, {\n                onItemPop: function (element) {\n                    mxn._setEndLocation(element, mxn.currentToken);\n                }\n            });\n        },\n\n        _runParsingLoop: function (scriptHandler) {\n            orig._runParsingLoop.call(this, scriptHandler);\n\n            // NOTE: generate location info for elements\n            // that remains on open element stack\n            for (var i = this.openElements.stackTop; i >= 0; i--)\n                mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n        },\n\n\n        //Token processing\n        _processTokenInForeignContent: function (token) {\n            mxn.currentToken = token;\n            orig._processTokenInForeignContent.call(this, token);\n        },\n\n        _processToken: function (token) {\n            mxn.currentToken = token;\n            orig._processToken.call(this, token);\n\n            //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n            //their end location explicitly.\n            var requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN &&\n                                        (token.tagName === $.HTML ||\n                                         token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n\n            if (requireExplicitUpdate) {\n                for (var i = this.openElements.stackTop; i >= 0; i--) {\n                    var element = this.openElements.items[i];\n\n                    if (this.treeAdapter.getTagName(element) === token.tagName) {\n                        mxn._setEndLocation(element, token);\n                        break;\n                    }\n                }\n            }\n        },\n\n\n        //Doctype\n        _setDocumentType: function (token) {\n            orig._setDocumentType.call(this, token);\n\n            var documentChildren = this.treeAdapter.getChildNodes(this.document),\n                cnLength = documentChildren.length;\n\n            for (var i = 0; i < cnLength; i++) {\n                var node = documentChildren[i];\n\n                if (this.treeAdapter.isDocumentTypeNode(node)) {\n                    node.__location = token.location;\n                    break;\n                }\n            }\n        },\n\n\n        //Elements\n        _attachElementToTree: function (element) {\n            //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n            //So we will use token location stored in this methods for the element.\n            mxn._setStartLocation(element);\n            mxn.lastStartTagToken = null;\n            orig._attachElementToTree.call(this, element);\n        },\n\n        _appendElement: function (token, namespaceURI) {\n            mxn.lastStartTagToken = token;\n            orig._appendElement.call(this, token, namespaceURI);\n        },\n\n        _insertElement: function (token, namespaceURI) {\n            mxn.lastStartTagToken = token;\n            orig._insertElement.call(this, token, namespaceURI);\n        },\n\n        _insertTemplate: function (token) {\n            mxn.lastStartTagToken = token;\n            orig._insertTemplate.call(this, token);\n\n            var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n            tmplContent.__location = null;\n        },\n\n        _insertFakeRootElement: function () {\n            orig._insertFakeRootElement.call(this);\n            this.openElements.current.__location = null;\n        },\n\n        //Comments\n        _appendCommentNode: function (token, parent) {\n            orig._appendCommentNode.call(this, token, parent);\n\n            var children = this.treeAdapter.getChildNodes(parent),\n                commentNode = children[children.length - 1];\n\n            commentNode.__location = token.location;\n        },\n\n        //Text\n        _findFosterParentingLocation: function () {\n            //NOTE: store last foster parenting location, so we will be able to find inserted text\n            //in case of foster parenting\n            mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n\n            return mxn.lastFosterParentingLocation;\n        },\n\n        _insertCharacters: function (token) {\n            orig._insertCharacters.call(this, token);\n\n            var hasFosterParent = this._shouldFosterParentOnInsertion(),\n                parent = hasFosterParent && mxn.lastFosterParentingLocation.parent ||\n                         this.openElements.currentTmplContent ||\n                         this.openElements.current,\n                siblings = this.treeAdapter.getChildNodes(parent),\n                textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ?\n                siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 :\n                siblings.length - 1,\n                textNode = siblings[textNodeIdx];\n\n            //NOTE: if we have location assigned by another token, then just update end position\n            if (textNode.__location)\n                textNode.__location.endOffset = token.location.endOffset;\n\n            else\n                textNode.__location = token.location;\n        }\n    };\n};\n\n"]},"metadata":{},"sourceType":"script"}