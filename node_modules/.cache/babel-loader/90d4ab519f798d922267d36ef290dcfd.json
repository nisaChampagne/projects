{"ast":null,"code":"'use strict';\n\nvar WritableStream = require('stream').Writable,\n    inherits = require('util').inherits,\n    Parser = require('./index');\n\nvar ParserStream = module.exports = function (options) {\n  WritableStream.call(this);\n  this.parser = new Parser(options);\n  this.lastChunkWritten = false;\n  this.writeCallback = null;\n  this.pausedByScript = false;\n  this.document = this.parser.treeAdapter.createDocument();\n  this.pendingHtmlInsertions = [];\n  this._resume = this._resume.bind(this);\n  this._documentWrite = this._documentWrite.bind(this);\n  this._scriptHandler = this._scriptHandler.bind(this);\n\n  this.parser._bootstrap(this.document, null);\n};\n\ninherits(ParserStream, WritableStream); //WritableStream implementation\n\nParserStream.prototype._write = function (chunk, encoding, callback) {\n  this.writeCallback = callback;\n  this.parser.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);\n\n  this._runParsingLoop();\n};\n\nParserStream.prototype.end = function (chunk, encoding, callback) {\n  this.lastChunkWritten = true;\n  WritableStream.prototype.end.call(this, chunk || '', encoding, callback);\n}; //Scriptable parser implementation\n\n\nParserStream.prototype._runParsingLoop = function () {\n  this.parser.runParsingLoopForCurrentChunk(this.writeCallback, this._scriptHandler);\n};\n\nParserStream.prototype._resume = function () {\n  if (!this.pausedByScript) throw new Error('Parser was already resumed');\n\n  while (this.pendingHtmlInsertions.length) {\n    var html = this.pendingHtmlInsertions.pop();\n    this.parser.tokenizer.insertHtmlAtCurrentPos(html);\n  }\n\n  this.pausedByScript = false; //NOTE: keep parsing if we don't wait for the next input chunk\n\n  if (this.parser.tokenizer.active) this._runParsingLoop();\n};\n\nParserStream.prototype._documentWrite = function (html) {\n  if (!this.parser.stopped) this.pendingHtmlInsertions.push(html);\n};\n\nParserStream.prototype._scriptHandler = function (scriptElement) {\n  if (this.listeners('script').length) {\n    this.pausedByScript = true;\n    this.emit('script', scriptElement, this._documentWrite, this._resume);\n  } else this._runParsingLoop();\n};","map":{"version":3,"sources":["/Users/lambda_school_loaner_244/Desktop/LAMBDA/projects/projectsCollection/node_modules/parse5/lib/parser/parser_stream.js"],"names":["WritableStream","require","Writable","inherits","Parser","ParserStream","module","exports","options","call","parser","lastChunkWritten","writeCallback","pausedByScript","document","treeAdapter","createDocument","pendingHtmlInsertions","_resume","bind","_documentWrite","_scriptHandler","_bootstrap","prototype","_write","chunk","encoding","callback","tokenizer","write","toString","_runParsingLoop","end","runParsingLoopForCurrentChunk","Error","length","html","pop","insertHtmlAtCurrentPos","active","stopped","push","scriptElement","listeners","emit"],"mappings":"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","sourcesContent":["'use strict';\n\nvar WritableStream = require('stream').Writable,\n    inherits = require('util').inherits,\n    Parser = require('./index');\n\nvar ParserStream = module.exports = function (options) {\n    WritableStream.call(this);\n\n    this.parser = new Parser(options);\n\n    this.lastChunkWritten = false;\n    this.writeCallback = null;\n    this.pausedByScript = false;\n\n    this.document = this.parser.treeAdapter.createDocument();\n\n    this.pendingHtmlInsertions = [];\n\n    this._resume = this._resume.bind(this);\n    this._documentWrite = this._documentWrite.bind(this);\n    this._scriptHandler = this._scriptHandler.bind(this);\n\n    this.parser._bootstrap(this.document, null);\n};\n\ninherits(ParserStream, WritableStream);\n\n//WritableStream implementation\nParserStream.prototype._write = function (chunk, encoding, callback) {\n    this.writeCallback = callback;\n    this.parser.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);\n    this._runParsingLoop();\n};\n\nParserStream.prototype.end = function (chunk, encoding, callback) {\n    this.lastChunkWritten = true;\n    WritableStream.prototype.end.call(this, chunk || '', encoding, callback);\n};\n\n//Scriptable parser implementation\nParserStream.prototype._runParsingLoop = function () {\n    this.parser.runParsingLoopForCurrentChunk(this.writeCallback, this._scriptHandler);\n};\n\nParserStream.prototype._resume = function () {\n    if (!this.pausedByScript)\n        throw new Error('Parser was already resumed');\n\n    while (this.pendingHtmlInsertions.length) {\n        var html = this.pendingHtmlInsertions.pop();\n\n        this.parser.tokenizer.insertHtmlAtCurrentPos(html);\n    }\n\n    this.pausedByScript = false;\n\n    //NOTE: keep parsing if we don't wait for the next input chunk\n    if (this.parser.tokenizer.active)\n        this._runParsingLoop();\n};\n\nParserStream.prototype._documentWrite = function (html) {\n    if (!this.parser.stopped)\n        this.pendingHtmlInsertions.push(html);\n};\n\nParserStream.prototype._scriptHandler = function (scriptElement) {\n    if (this.listeners('script').length) {\n        this.pausedByScript = true;\n        this.emit('script', scriptElement, this._documentWrite, this._resume);\n    }\n    else\n        this._runParsingLoop();\n};\n\n"]},"metadata":{},"sourceType":"script"}