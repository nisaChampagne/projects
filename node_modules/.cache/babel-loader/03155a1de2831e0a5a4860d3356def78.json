{"ast":null,"code":"'use strict';\n\nvar UNICODE = require('../common/unicode'); //Aliases\n\n\nvar $ = UNICODE.CODE_POINTS; //Utils\n//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline\n//this functions if they will be situated in another module due to context switch.\n//Always perform inlining check before modifying this functions ('node --trace-inlining').\n\nfunction isSurrogatePair(cp1, cp2) {\n  return cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF;\n}\n\nfunction getSurrogatePairCodePoint(cp1, cp2) {\n  return (cp1 - 0xD800) * 0x400 + 0x2400 + cp2;\n} //Const\n\n\nvar DEFAULT_BUFFER_WATERLINE = 1 << 16; //Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\n\nvar Preprocessor = module.exports = function () {\n  this.html = null;\n  this.pos = -1;\n  this.lastGapPos = -1;\n  this.lastCharPos = -1;\n  this.gapStack = [];\n  this.skipNextNewLine = false;\n  this.lastChunkWritten = false;\n  this.endOfChunkHit = false;\n  this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n};\n\nPreprocessor.prototype.dropParsedChunk = function () {\n  if (this.pos > this.bufferWaterline) {\n    this.lastCharPos -= this.pos;\n    this.html = this.html.substring(this.pos);\n    this.pos = 0;\n    this.lastGapPos = -1;\n    this.gapStack = [];\n  }\n};\n\nPreprocessor.prototype._addGap = function () {\n  this.gapStack.push(this.lastGapPos);\n  this.lastGapPos = this.pos;\n};\n\nPreprocessor.prototype._processHighRangeCodePoint = function (cp) {\n  //NOTE: try to peek a surrogate pair\n  if (this.pos !== this.lastCharPos) {\n    var nextCp = this.html.charCodeAt(this.pos + 1);\n\n    if (isSurrogatePair(cp, nextCp)) {\n      //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n      this.pos++;\n      cp = getSurrogatePairCodePoint(cp, nextCp); //NOTE: add gap that should be avoided during retreat\n\n      this._addGap();\n    }\n  } // NOTE: we've hit the end of chunk, stop processing at this point\n  else if (!this.lastChunkWritten) {\n      this.endOfChunkHit = true;\n      return $.EOF;\n    }\n\n  return cp;\n};\n\nPreprocessor.prototype.write = function (chunk, isLastChunk) {\n  if (this.html) this.html += chunk;else this.html = chunk;\n  this.lastCharPos = this.html.length - 1;\n  this.endOfChunkHit = false;\n  this.lastChunkWritten = isLastChunk;\n};\n\nPreprocessor.prototype.insertHtmlAtCurrentPos = function (chunk) {\n  this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);\n  this.lastCharPos = this.html.length - 1;\n  this.endOfChunkHit = false;\n};\n\nPreprocessor.prototype.advance = function () {\n  this.pos++;\n\n  if (this.pos > this.lastCharPos) {\n    if (!this.lastChunkWritten) this.endOfChunkHit = true;\n    return $.EOF;\n  }\n\n  var cp = this.html.charCodeAt(this.pos); //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n  //must be ignored.\n\n  if (this.skipNextNewLine && cp === $.LINE_FEED) {\n    this.skipNextNewLine = false;\n\n    this._addGap();\n\n    return this.advance();\n  } //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n\n\n  if (cp === $.CARRIAGE_RETURN) {\n    this.skipNextNewLine = true;\n    return $.LINE_FEED;\n  }\n\n  this.skipNextNewLine = false; //OPTIMIZATION: first perform check if the code point in the allowed range that covers most common\n  //HTML input (e.g. ASCII codes) to avoid performance-cost operations for high-range code points.\n\n  return cp >= 0xD800 ? this._processHighRangeCodePoint(cp) : cp;\n};\n\nPreprocessor.prototype.retreat = function () {\n  if (this.pos === this.lastGapPos) {\n    this.lastGapPos = this.gapStack.pop();\n    this.pos--;\n  }\n\n  this.pos--;\n};","map":{"version":3,"sources":["/Users/lambda_school_loaner_244/Desktop/LAMBDA/projects/projectsCollection/node_modules/parse5/lib/tokenizer/preprocessor.js"],"names":["UNICODE","require","$","CODE_POINTS","isSurrogatePair","cp1","cp2","getSurrogatePairCodePoint","DEFAULT_BUFFER_WATERLINE","Preprocessor","module","exports","html","pos","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","prototype","dropParsedChunk","substring","_addGap","push","_processHighRangeCodePoint","cp","nextCp","charCodeAt","EOF","write","chunk","isLastChunk","length","insertHtmlAtCurrentPos","advance","LINE_FEED","CARRIAGE_RETURN","retreat","pop"],"mappings":"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","sourcesContent":["'use strict';\n\nvar UNICODE = require('../common/unicode');\n\n//Aliases\nvar $ = UNICODE.CODE_POINTS;\n\n//Utils\n\n//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline\n//this functions if they will be situated in another module due to context switch.\n//Always perform inlining check before modifying this functions ('node --trace-inlining').\nfunction isSurrogatePair(cp1, cp2) {\n    return cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF;\n}\n\nfunction getSurrogatePairCodePoint(cp1, cp2) {\n    return (cp1 - 0xD800) * 0x400 + 0x2400 + cp2;\n}\n\n\n//Const\nvar DEFAULT_BUFFER_WATERLINE = 1 << 16;\n\n\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nvar Preprocessor = module.exports = function () {\n    this.html = null;\n\n    this.pos = -1;\n    this.lastGapPos = -1;\n    this.lastCharPos = -1;\n\n    this.gapStack = [];\n\n    this.skipNextNewLine = false;\n\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n};\n\nPreprocessor.prototype.dropParsedChunk = function () {\n    if (this.pos > this.bufferWaterline) {\n        this.lastCharPos -= this.pos;\n        this.html = this.html.substring(this.pos);\n        this.pos = 0;\n        this.lastGapPos = -1;\n        this.gapStack = [];\n    }\n};\n\nPreprocessor.prototype._addGap = function () {\n    this.gapStack.push(this.lastGapPos);\n    this.lastGapPos = this.pos;\n};\n\nPreprocessor.prototype._processHighRangeCodePoint = function (cp) {\n    //NOTE: try to peek a surrogate pair\n    if (this.pos !== this.lastCharPos) {\n        var nextCp = this.html.charCodeAt(this.pos + 1);\n\n        if (isSurrogatePair(cp, nextCp)) {\n            //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n            this.pos++;\n            cp = getSurrogatePairCodePoint(cp, nextCp);\n\n            //NOTE: add gap that should be avoided during retreat\n            this._addGap();\n        }\n    }\n\n    // NOTE: we've hit the end of chunk, stop processing at this point\n    else if (!this.lastChunkWritten) {\n        this.endOfChunkHit = true;\n        return $.EOF;\n    }\n\n    return cp;\n};\n\nPreprocessor.prototype.write = function (chunk, isLastChunk) {\n    if (this.html)\n        this.html += chunk;\n\n    else\n        this.html = chunk;\n\n    this.lastCharPos = this.html.length - 1;\n    this.endOfChunkHit = false;\n    this.lastChunkWritten = isLastChunk;\n};\n\nPreprocessor.prototype.insertHtmlAtCurrentPos = function (chunk) {\n    this.html = this.html.substring(0, this.pos + 1) +\n                chunk +\n                this.html.substring(this.pos + 1, this.html.length);\n\n    this.lastCharPos = this.html.length - 1;\n    this.endOfChunkHit = false;\n};\n\n\nPreprocessor.prototype.advance = function () {\n    this.pos++;\n\n    if (this.pos > this.lastCharPos) {\n        if (!this.lastChunkWritten)\n            this.endOfChunkHit = true;\n\n        return $.EOF;\n    }\n\n    var cp = this.html.charCodeAt(this.pos);\n\n    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n    //must be ignored.\n    if (this.skipNextNewLine && cp === $.LINE_FEED) {\n        this.skipNextNewLine = false;\n        this._addGap();\n        return this.advance();\n    }\n\n    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n    if (cp === $.CARRIAGE_RETURN) {\n        this.skipNextNewLine = true;\n        return $.LINE_FEED;\n    }\n\n    this.skipNextNewLine = false;\n\n    //OPTIMIZATION: first perform check if the code point in the allowed range that covers most common\n    //HTML input (e.g. ASCII codes) to avoid performance-cost operations for high-range code points.\n    return cp >= 0xD800 ? this._processHighRangeCodePoint(cp) : cp;\n};\n\nPreprocessor.prototype.retreat = function () {\n    if (this.pos === this.lastGapPos) {\n        this.lastGapPos = this.gapStack.pop();\n        this.pos--;\n    }\n\n    this.pos--;\n};\n\n"]},"metadata":{},"sourceType":"script"}